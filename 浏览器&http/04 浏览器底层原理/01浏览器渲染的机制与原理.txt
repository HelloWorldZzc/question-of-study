1、进程process 线程thread 栈内存 stack
    开启一个应用，可以理解成为一个进程，有些进程不止同时做一件事情，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些子任务称为线程
    多个线程可以同时执行，多线程执行方式和多线程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样

2、浏览器的执行过程
    1）客户端输入网址--->request请求：（DNS解析，TCP协议的三次握手与四次握手）
    ----->在web服务器端找到相关的资源---->request相应阶段
    2）拿到代码后：浏览器在内存中开辟出一块栈内存，用来给代码的执行提供环境，同时分配一个主线程去一行一行的解释和执行代码
        tip:浏览器是多线程的程序，只是分配了一个线程来处理页面的程序，js是单线程（执行的只有一个）
    3）进栈执行的过程中：
        当浏览器遇到link/script/img等请求后，都会开辟全新的线程去加载资源文件
        此时主线程需要继续往下执行
        例如需要link 1.css link 2.css
        在task queue任务队列中添加任务 请求1.css 2.css...
    4）在自上而下第一次走完以后，生成DOM树，此时在task queue中一直循环（event loop 时间循环）
     在css处理完成生成cssom之后，DOM与cssom生成render tree渲染树













3、浏览器渲染页面的机制与原理
    1）解析HTML，生成DOM树，解析css，生成cssOM树
    2) 将DOM树和cssOM树结合，生成渲染树（Render Tree）
    3) 回流(Reflow)：根据生成的渲染树，计算他们在设备视口（viewport）内的确切位置和大小，这个计算的阶段就是回流
    4）重绘(Repaint)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
    3）display：将像素发送给GPU,展示在页面上
4、回流与重绘：
    重绘：元素样式的改变（但是宽高，大小，位置等不发生改变）
        比如outline、color、background-color等
    回流：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染
        比如：添加或者删除可见的DOM元素；元素的位置发生变化，元素的尺寸发生变化，内容发生变化，页面一开始渲染
        因为回流是根据视口的大小来计算元素的位置和大小的，所以浏览器的窗口尺寸的变化也会引发回流
    关系：回流一定会触发重绘，而重绘不一定会回流